{{/*
###
# Custom Functions
###
*/ -}}

# Time ZSH loadup, read more here: https://blog.mattclemente.com/2020/06/26/oh-my-zsh-slow-to-load.html#summary
timezsh() {
  shell=${1-$SHELL}
  for i in $(seq 1 10); do /usr/bin/time $shell -i -c exit; done
}

# Time p10k loadup, read more here: https://github.com/romkatv/powerlevel10k/blob/master/README.md#is-powerlevel10k-fast-to-load
timep10k() {
  time (repeat 10 zsh -dfis <<< 'source ~/.p10k.zsh; source ~/.oh-my-zsh/custom/themes/powerlevel10k/powerlevel10k.zsh-theme')
}

# Kill apps that match string
# Based on script found on here: https://github.com/sunknudsen/privacy-guides/tree/master/how-to-make-sure-app-is-not-running-in-the-background-on-macos
function killapps() {
  IFS=$'\n'
  red=$(tput setaf 1)
  normal=$(tput sgr0)
  if [ -z "$1" ] || [ "$1" = "--help" ]; then
    printf "%s\n" "Usage: kill-apps string"
    return 0
  fi
  printf "%s\n" "Finding apps that match “$1”…"
  sleep 1
  processes=($(pgrep -afil "$1"))
  if [ ${#processes[@]} -eq 0 ]; then
    printf "%s\n" "No apps found"
    return 0
  else
    printf "%s\n" "${processes[@]}"
    printf "$red%s$normal" "Kill found apps (y or n)? "
    read -r answer
    if [ "$answer" = "y" ]; then
      printf "%s\n" "Killing found apps…"
      sleep 1
      for process in "${processes[@]}"; do
        echo $process | awk '{print $1}' | xargs sudo kill 2>&1 | grep -v "No such process"
      done
      printf "%s\n" "Done"
      return 0
    fi
  fi
}

###
# AWS SSO helper functions
###

function _get_aws_profile() {
    local config=~/.aws/config
    test ! -f ${config} && echo "File ${config} does not exist" && return 1

    local profile_regex='s/\[profile \(.*\)]/\1/'

    if which fzf 2>&1 >/dev/null; then
        echo $(cat "${config}" | grep '\[profile' | sed ${profile_regex} | fzf)
    else
        select _aws_profile in $(cat "${config}" | grep '\[profile' | sed ${profile_regex}); do
            echo $_aws_profile;
            break;
        done
    fi
}

function _get_aws_region() {
    local _aws_profile="${1:-default}"
    local _config=~/.aws/config
    readonly PROFILE_CONFIG="$(sed -n "/${_aws_profile}/,/^ *$/p" "${_config}")"

    local region=""
    [[ -z "${region}" ]] && region=$(echo "${PROFILE_CONFIG}" |  (grep '\<region *=.*\>' || true) | sed -E 's/^region *= *([^ ]*).*$/\1/')
    echo $region
}

function aws_profile() {
  local aws_profile

  # Iterate through command-line arguments
  for arg in "$@"; do
    if [[ "$arg" == "--profile="* ]]; then
      aws_profile="${arg#*=}"
      shift
    fi
  done

  # If no '--profile' then select profile from list
  if [[ -z "$aws_profile" ]]; then
    aws_profile="$(_get_aws_profile)"
  fi

  export AWS_DEFAULT_REGION=$(_get_aws_region "default")
  export AWS_DEFAULT_PROFILE=$aws_profile
  export AWS_PROFILE=$aws_profile
  export AWS_EB_PROFILE=$aws_profile

  # Check for 'login' argument
  if [[ "$1" == "login" ]]; then
    aws sso login --profile "$aws_profile"
    eval "$(aws configure export-credentials --profile "$aws_profile" --format env)"
    export AWS_PROFILE_REGION=$(aws configure get region)
  fi
}

alias ap='aws_profile'
alias al='aws_profile login'

###
# Bump repo version
###

function bump_version() {
  # Thanks goes to @pete-otaqui for the initial gist:
  # https://gist.github.com/pete-otaqui/4188238
  #
  # Original version modified by Marek Suscak
  #
  # works with a file called VERSION in the current directory,
  # the contents of which should be a semantic version number
  # such as "1.2.3" or even "1.2.3-beta+001.ab"

  # this script will display the current version, automatically
  # suggest a "minor" version update, and ask for input to use
  # the suggestion, or a newly entered value.

  # once the new version number is determined, the script will
  # pull a list of changes from git history, prepend this to
  # a file called CHANGELOG.md (under the title of the new version
  # number), give user a chance to review and update the changelist
  # manually if needed and create a GIT tag.

  REMOTE_REPO=${1:-origin}

  NOW="$(date +'%B %d, %Y')"
  RED="\033[1;31m"
  GREEN="\033[0;32m"
  YELLOW="\033[1;33m"
  BLUE="\033[1;34m"
  PURPLE="\033[1;35m"
  CYAN="\033[1;36m"
  WHITE="\033[1;37m"
  RESET="\033[0m"

  LATEST_HASH=`git log --pretty=format:'%h' -n 1`

  QUESTION_FLAG="${GREEN}?"
  WARNING_FLAG="${YELLOW}!"
  NOTICE_FLAG="${CYAN}❯"

  ADJUSTMENTS_MSG="${QUESTION_FLAG} ${CYAN}Now you can make adjustments to ${WHITE}CHANGELOG.md${CYAN}. Then press enter to continue."
  PUSHING_MSG="${NOTICE_FLAG} Pushing new version to the ${WHITE}${REMOTE_REPO}${CYAN}..."

  if [ -f VERSION ]; then
      BASE_STRING=`cat VERSION`
      BASE_LIST=(`echo $BASE_STRING | tr '.' ' '`)
      V_MAJOR=${BASE_LIST[0]}
      V_MINOR=${BASE_LIST[1]}
      V_PATCH=${BASE_LIST[2]}
      echo -e "${NOTICE_FLAG} Current version: ${WHITE}$BASE_STRING"
      echo -e "${NOTICE_FLAG} Latest commit hash: ${WHITE}$LATEST_HASH"
      V_PATCH=$((V_PATCH + 1))
      SUGGESTED_VERSION="$V_MAJOR.$V_MINOR.$V_PATCH"
      echo -ne "${QUESTION_FLAG} ${CYAN}Enter a version number [${WHITE}$SUGGESTED_VERSION${CYAN}]: "
      read INPUT_STRING
      if [ "$INPUT_STRING" = "" ]; then
          INPUT_STRING=$SUGGESTED_VERSION
      fi
      echo -e "${NOTICE_FLAG} Will set new version to be ${WHITE}$INPUT_STRING"
      echo $INPUT_STRING > VERSION
      echo "## $INPUT_STRING ($NOW)" > tmpfile
      git log --pretty=format:"  - %s" "v$BASE_STRING"...HEAD >> tmpfile
      echo "" >> tmpfile
      echo "" >> tmpfile
      cat CHANGELOG.md >> tmpfile
      mv tmpfile CHANGELOG.md
      echo -e "$ADJUSTMENTS_MSG"
      read
      echo -e "$PUSHING_MSG"
      git add CHANGELOG.md VERSION
      git commit -m "chore: bump version to ${INPUT_STRING}"
      git tag -a -m "Tag version ${INPUT_STRING}." "v$INPUT_STRING"
      git push $REMOTE_REPO --tags -o ci.skip
  else
      echo -e "${WARNING_FLAG} Could not find a VERSION file."
      echo -ne "${QUESTION_FLAG} ${CYAN}Do you want to create a version file and start from scratch? [${WHITE}y${CYAN}]: "
      read RESPONSE
      if [ "$RESPONSE" = "" ]; then RESPONSE="y"; fi
      if [ "$RESPONSE" = "Y" ]; then RESPONSE="y"; fi
      if [ "$RESPONSE" = "Yes" ]; then RESPONSE="y"; fi
      if [ "$RESPONSE" = "yes" ]; then RESPONSE="y"; fi
      if [ "$RESPONSE" = "YES" ]; then RESPONSE="y"; fi
      if [ "$RESPONSE" = "y" ]; then
          echo "0.1.0" > VERSION
          echo "## 0.1.0 ($NOW)" > CHANGELOG.md
          git log --pretty=format:"  - %s" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo -e "$ADJUSTMENTS_MSG"
          read
          echo -e "$PUSHING_MSG"
          git add VERSION CHANGELOG.md
          git commit -m "chore: add VERSION and CHANGELOG.md files, bump version to v0.1.0."
          git tag -a -m "Tag version 0.1.0." "v0.1.0"
          git push $REMOTE_REPO --tags -o ci.skip
      fi
  fi

  echo -e "${NOTICE_FLAG} Finished."
}
